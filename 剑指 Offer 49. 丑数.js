/* 剑指 Offer 49. 丑数
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

 

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 */

/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
  if(n <= 0) return 0
  //基础丑数为1
  const dp = [1]
  //初始分别指向三个有序链表第一个元素,这三个有序链表是想象出来的，分别就是ugly数组元素分别乘以2,3,5得到的

/*   我们知道，丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}

B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}

C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}

那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。

合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。*/
  let id2 = 0,id3 = 0, id5 = 0
  for(let i = 1; i < n; i++){
      dp[i] = Math.min(dp[id2]*2,dp[id3]*3,dp[id5]*5)
       //三个链表可能有相同元素，所以只要是最小的，都要移动指针
      if(dp[i] === dp[id2]*2) id2++
      if(dp[i] === dp[id3]*3) id3++
      if(dp[i] === dp[id5]*5) id5++
  }
  return dp[n-1]
};