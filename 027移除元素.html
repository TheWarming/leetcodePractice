<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
			// 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
			
			// 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
			
			// 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
			
			//  

			var removeElement = function(nums, val) {
			    if(nums.length === 0) return 0 
			    let i = 0
			    for(let j = 0; j < nums.length; j++){
			        if(nums[j] != val){
			            nums[i] = nums[j];
			            i++;
			        }
			    }
			    return i
			};
			
			// 方法二：双指针 —— 当要删除的元素很少时
			// 思路
			
			// 现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。
			
			// 算法
			
			// 当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。
			
			// 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。
			// public int removeElement(int[] nums, int val) {
			//     int i = 0;
			//     int n = nums.length;
			//     while (i < n) {
			//         if (nums[i] == val) {
			//             nums[i] = nums[n - 1];
			//             // reduce array size by one
			//             n--;
			//         } else {
			//             i++;
			//         }
			//     }
			//     return n;
			// }
			let removeElement2 = function(nums,val){
				let i = 0;
				let n = nums.length;
				while(i < n){
					if(nums[i] === val){
						nums[i] = nums[n - 1];
						n--;
					} else {
						i++;
					}
				}
				return n;
			}
		</script>
	</body>
</html>
